{"ast":null,"code":"/*\nHTML escaping is the same as React's\n(on purpose.) Therefore, it has the following Copyright and Licensing:\n\nCopyright 2013-2014, Facebook, Inc.\nAll rights reserved.\n\nThis source code is licensed under the BSD-style license found in the LICENSE\nfile in the root directory of React's source tree.\n*/\nimport * as React from 'react';\nimport IntlMessageFormat from 'intl-messageformat';\nimport memoizeIntlConstructor from 'intl-format-cache'; // Since rollup cannot deal with namespace being a function,\n// this is to interop with TypeScript since `invariant`\n// does not export a default\n// https://github.com/rollup/rollup/issues/1267\n\nimport * as invariant_ from 'invariant';\nconst invariant = invariant_.default || invariant_;\nconst ESCAPED_CHARS = {\n  38: '&amp;',\n  62: '&gt;',\n  60: '&lt;',\n  34: '&quot;',\n  39: '&#x27;'\n};\nconst UNSAFE_CHARS_REGEX = /[&><\"']/g;\nexport function escape(str) {\n  return ('' + str).replace(UNSAFE_CHARS_REGEX, match => ESCAPED_CHARS[match.charCodeAt(0)]);\n}\nexport function filterProps(props, whitelist, defaults = {}) {\n  return whitelist.reduce((filtered, name) => {\n    if (name in props) {\n      filtered[name] = props[name];\n    } else if (name in defaults) {\n      filtered[name] = defaults[name];\n    }\n\n    return filtered;\n  }, {});\n}\nexport function invariantIntlContext(intl) {\n  invariant(intl, '[React Intl] Could not find required `intl` object. ' + '<IntlProvider> needs to exist in the component ancestry.');\n}\nexport function createError(message, exception) {\n  const eMsg = exception ? `\\n${exception.stack}` : '';\n  return `[React Intl] ${message}${eMsg}`;\n}\nexport function defaultErrorHandler(error) {\n  if (process.env.NODE_ENV !== 'production') {\n    console.error(error);\n  }\n}\nexport const DEFAULT_INTL_CONFIG = {\n  formats: {},\n  messages: {},\n  timeZone: undefined,\n  textComponent: React.Fragment,\n  defaultLocale: 'en',\n  defaultFormats: {},\n  onError: defaultErrorHandler\n};\nexport function createIntlCache() {\n  return {\n    dateTime: {},\n    number: {},\n    message: {},\n    relativeTime: {},\n    pluralRules: {},\n    list: {}\n  };\n}\n/**\n * Create intl formatters and populate cache\n * @param cache explicit cache to prevent leaking memory\n */\n\nexport function createFormatters(cache = createIntlCache()) {\n  const RelativeTimeFormat = Intl.RelativeTimeFormat;\n  const ListFormat = Intl.ListFormat;\n  return {\n    getDateTimeFormat: memoizeIntlConstructor(Intl.DateTimeFormat, cache.dateTime),\n    getNumberFormat: memoizeIntlConstructor(Intl.NumberFormat, cache.number),\n    getMessageFormat: memoizeIntlConstructor(IntlMessageFormat, cache.message),\n    getRelativeTimeFormat: memoizeIntlConstructor(RelativeTimeFormat, cache.relativeTime),\n    getPluralRules: memoizeIntlConstructor(Intl.PluralRules, cache.pluralRules),\n    getListFormat: memoizeIntlConstructor(ListFormat, cache.list)\n  };\n}\nexport function getNamedFormat(formats, type, name, onError) {\n  const formatType = formats && formats[type];\n  let format;\n\n  if (formatType) {\n    format = formatType[name];\n  }\n\n  if (format) {\n    return format;\n  }\n\n  onError(createError(`No ${type} format named: ${name}`));\n}","map":{"version":3,"sources":["/Users/chengpeng/workspace/Ft-Official-Website/ft-offical-website/node_modules/react-intl/lib/utils.js"],"names":["React","IntlMessageFormat","memoizeIntlConstructor","invariant_","invariant","default","ESCAPED_CHARS","UNSAFE_CHARS_REGEX","escape","str","replace","match","charCodeAt","filterProps","props","whitelist","defaults","reduce","filtered","name","invariantIntlContext","intl","createError","message","exception","eMsg","stack","defaultErrorHandler","error","process","env","NODE_ENV","console","DEFAULT_INTL_CONFIG","formats","messages","timeZone","undefined","textComponent","Fragment","defaultLocale","defaultFormats","onError","createIntlCache","dateTime","number","relativeTime","pluralRules","list","createFormatters","cache","RelativeTimeFormat","Intl","ListFormat","getDateTimeFormat","DateTimeFormat","getNumberFormat","NumberFormat","getMessageFormat","getRelativeTimeFormat","getPluralRules","PluralRules","getListFormat","getNamedFormat","type","formatType","format"],"mappings":"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","sourcesContent":["/*\nHTML escaping is the same as React's\n(on purpose.) Therefore, it has the following Copyright and Licensing:\n\nCopyright 2013-2014, Facebook, Inc.\nAll rights reserved.\n\nThis source code is licensed under the BSD-style license found in the LICENSE\nfile in the root directory of React's source tree.\n*/\nimport * as React from 'react';\nimport IntlMessageFormat from 'intl-messageformat';\nimport memoizeIntlConstructor from 'intl-format-cache';\n// Since rollup cannot deal with namespace being a function,\n// this is to interop with TypeScript since `invariant`\n// does not export a default\n// https://github.com/rollup/rollup/issues/1267\nimport * as invariant_ from 'invariant';\nconst invariant = invariant_.default || invariant_;\nconst ESCAPED_CHARS = {\n    38: '&amp;',\n    62: '&gt;',\n    60: '&lt;',\n    34: '&quot;',\n    39: '&#x27;',\n};\nconst UNSAFE_CHARS_REGEX = /[&><\"']/g;\nexport function escape(str) {\n    return ('' + str).replace(UNSAFE_CHARS_REGEX, match => ESCAPED_CHARS[match.charCodeAt(0)]);\n}\nexport function filterProps(props, whitelist, defaults = {}) {\n    return whitelist.reduce((filtered, name) => {\n        if (name in props) {\n            filtered[name] = props[name];\n        }\n        else if (name in defaults) {\n            filtered[name] = defaults[name];\n        }\n        return filtered;\n    }, {});\n}\nexport function invariantIntlContext(intl) {\n    invariant(intl, '[React Intl] Could not find required `intl` object. ' +\n        '<IntlProvider> needs to exist in the component ancestry.');\n}\nexport function createError(message, exception) {\n    const eMsg = exception ? `\\n${exception.stack}` : '';\n    return `[React Intl] ${message}${eMsg}`;\n}\nexport function defaultErrorHandler(error) {\n    if (process.env.NODE_ENV !== 'production') {\n        console.error(error);\n    }\n}\nexport const DEFAULT_INTL_CONFIG = {\n    formats: {},\n    messages: {},\n    timeZone: undefined,\n    textComponent: React.Fragment,\n    defaultLocale: 'en',\n    defaultFormats: {},\n    onError: defaultErrorHandler,\n};\nexport function createIntlCache() {\n    return {\n        dateTime: {},\n        number: {},\n        message: {},\n        relativeTime: {},\n        pluralRules: {},\n        list: {},\n    };\n}\n/**\n * Create intl formatters and populate cache\n * @param cache explicit cache to prevent leaking memory\n */\nexport function createFormatters(cache = createIntlCache()) {\n    const RelativeTimeFormat = Intl.RelativeTimeFormat;\n    const ListFormat = Intl.ListFormat;\n    return {\n        getDateTimeFormat: memoizeIntlConstructor(Intl.DateTimeFormat, cache.dateTime),\n        getNumberFormat: memoizeIntlConstructor(Intl.NumberFormat, cache.number),\n        getMessageFormat: memoizeIntlConstructor(IntlMessageFormat, cache.message),\n        getRelativeTimeFormat: memoizeIntlConstructor(RelativeTimeFormat, cache.relativeTime),\n        getPluralRules: memoizeIntlConstructor(Intl.PluralRules, cache.pluralRules),\n        getListFormat: memoizeIntlConstructor(ListFormat, cache.list),\n    };\n}\nexport function getNamedFormat(formats, type, name, onError) {\n    const formatType = formats && formats[type];\n    let format;\n    if (formatType) {\n        format = formatType[name];\n    }\n    if (format) {\n        return format;\n    }\n    onError(createError(`No ${type} format named: ${name}`));\n}\n"]},"metadata":{},"sourceType":"module"}